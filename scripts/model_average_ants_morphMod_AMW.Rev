################################################################################
#
# RevBayes Example: Bayesian model averaging using reversible-jump MCMC over
#            Mk and SHDM models using morphological character data.
#
################################################################################

####################
# Read in the data #
####################
this_gene = "AntMegaMatrixMinusAmbig"

data = readDiscreteCharacterData("data/" + this_gene + ".nex")

# get some useful information about the data
taxa = data.taxa()
num_taxa = data.ntaxa()
num_branches = 2 * num_taxa - 3

# Create some vector for the moves and monitors of this analysis
moves    = VectorMoves()
monitors = VectorMonitors()

# name the analysis
name = this_gene + "_" + "RJ"

# Set up branch length moves
br_len_lambda ~ dnExp(0.2)
moves.append( mvScale(br_len_lambda, weight=5))

nbr <- 2*taxa.size() - 3
for (i in 1:nbr){
    br_lens[i] ~ dnExponential(br_len_lambda)
    moves.append(mvScale(br_lens[i]))
}

#`Create a starting tree and place moves.append on it.
tau ~ dnUniformTopology(taxa)
phylogeny := treeAssembly(tau, br_lens)
moves.append(mvNNI(tau, weight=2*nbr))
moves.append( mvSPR(tau, weight=nbr))
tree_length := phylogeny.treeLength()
###########################################
# Mk Model
###########################################

n_max_states <- 7
idx = 1
morpho_bystate[1] <- data
for (i in 2:n_max_states) {
    morpho_bystate[i] <- data                                # make local tmp copy of data
    morpho_bystate[i].setNumStatesPartition(i)                 # only keep character blocks with state space equal to size i
    nc = morpho_bystate[i].nchar()                             # get number of characters per character size with i-sized states

    if (nc > 0) {                                              # for non-empty character blocks
        Q_Mk[idx] <- fnJC(i)                                      # make i-by-i rate matrix
        idx = idx + 1                                          # increment counter
        idx
    }
}
###########################################
#SHDM Model
##########################################
n_cats = 3
n_max_states <- 7
idx = 1

# Draw the concentration parameter of the Dirichlet prior from an exponential hyperprior
dir_alpha ~ dnExponential(1)
moves.append( mvScale(dir_alpha, lambda=1, weight=1.0 ) )
moves.append( mvScale(dir_alpha, lambda=0.1, weight=3.0 ) )
moves.append( mvScale(dir_alpha, lambda=0.01, weight=5.0 ) )

for (i in 2:n_max_states) {
    morpho_bystate[i - 1] <- data
    morpho_bystate[i - 1].setNumStatesPartition(i)
    nc = morpho_bystate[i - 1].nchar()
    if (nc > 0) {
      pi_prior[idx] := rep(dir_alpha, i)

      for (j in 1:n_cats) {
          pi[idx][j] ~ dnDirichlet(pi_prior[idx])
          moves.append(mvSimplexElementScale(pi[idx][j], alpha=10, weight=1.0))

          # reverse the pi[idx][j] vector
          upper = pi[idx][j].size()
          for (k in 1:upper) {
              ind = upper + 1 - k
              rev_pi[idx][j][k] <- pi[idx][j][ind]
          }

          # make i-by-i rate matrix
          Q_SHDM[idx][2*j - 1] := fnF81(pi[idx][j])
          # need to apply simplex() to convert rev_pi[idx][j] from type Probability[]
          Q_SHDM[idx][2*j] := fnF81(simplex(rev_pi[idx][j]))
      }

      print("The mixture contains "+Q_SHDM[idx].size()+" Q-matrices:")
      for (l in 1:Q_SHDM[idx].size()) {
          print(" ")
          Q_SHDM[idx][l]
      }

      mat_prior[idx] <- rep(1, 2*n_cats)
      matrix_probs[idx] ~ dnDirichlet(mat_prior[idx])

      moves.append( mvBetaSimplex(matrix_probs[idx], weight=3.0) )
      moves.append( mvDirichletSimplex(matrix_probs[idx], weight=1.5) )
      idx = idx + 1
    }
}

##########################################

#Q_vec = v(Q_Mk, Q_SHDM)

model_indicator ~ dnCategorical(simplex(1,1))
moves.append( mvRandomGeometricWalk(model_indicator, weight=10.0, tune=FALSE) )

#Q := Q_vec[model_indicator]


# Alternative approch
#Q ~ dnMixture( values=Q_vec, probabilities=simplex(rep(1,Q_vec.size())) )
#model_indicator := Q.getAllocationIndex()
#
#moves.append( mvGibbsMixtureAllocation(Q, weight=2.0)

#################################################
# Define the model of among-site rate variation #
#################################################

alpha ~ dnReversibleJumpMixture(1E8, dnUniform(0,1E8), 0.5)
moves.append( mvRJSwitch(alpha, weight=10.0) )
moves.append( mvScale(alpha, weight=10.0) )

alpha_indicator := ifelse(alpha == 1E8, 0, 1)

site_rates := fnDiscretizeGamma(alpha, alpha, 4)

#################################
# Define the phyloCTMC model    #
# (AKA the likelihood function) #
#################################

n_max_states <- 7
idx = 1

if (model_indicator == 1){
    morpho_bystate[1] <- data
    for (i in 2:n_max_states) {
        morpho_bystate[i] <- data                                # make local tmp copy of data
        morpho_bystate[i].setNumStatesPartition(i)
        seq ~ dnPhyloCTMC(tree=phylogeny, Q=Q_Mk[idx], type="standard", siteRates=site_rates)
        seq.clamp(morpho_bystate[i]) # attach the observed data
        }
} else {
    morpho_bystate[1] <- data
    for (i in 2:n_max_states) {
        morpho_bystate[i] <- data                                # make local tmp copy of data
        morpho_bystate[i].setNumStatesPartition(i)
      m_morph[idx] ~ dnPhyloCTMC(tree=phylogeny, siteRates=rates_morpho, Q=Q[idx],
                                 type="Standard", siteMatrices=matrix_probs[idx])
      m_morph[idx].clamp(morpho_bystate[i])
      }
      }
#########################
# Make the model object #
#########################

my_model = model(phylogeny)

#####################
# Make the monitors #
#####################

monitors.append( mnModel(filename="output/" + name + "/posterior_samples.log",printgen=10, separator = TAB) )
monitors.append( mnFile(filename="output/" + name + "/tree_samples.trees",printgen=10, separator = TAB, phylogeny) )
monitors.append( mnScreen(printgen=1000, model_indicator, alpha_indicator) )

################
# Run the MCMC #
################

mymcmc = mcmc(my_model, moves, monitors, nruns=2, combine="mixed")
mymcmc.run(generations=20000,tuningInterval=200)

#########################################
# Read in the posterior sample of trees #
# and compute the MAP tree              #
#########################################

# start by reading in the tree trace
treetrace = readTreeTrace("output/" + name + "/tree_samples.trees")
map_tree = mapTree(treetrace,"output/" + name + "/MAP_tree.tree")

# exit the program
q()
