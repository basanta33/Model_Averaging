################################################################################
#
# RevBayes Example: Bayesian model averaging using reversible-jump MCMC over
#            Mk and SHDM models using morphological character data.
#
################################################################################


####################
# Read in the data #
####################
this_gene = "AntMegaMatrixMinusAmbig"

data = readDiscreteCharacterData("data/" + this_gene + ".nex")

# get some useful information about the data
taxa = data.taxa()
num_taxa = data.ntaxa()
num_branches = 2 * num_taxa - 3

# Create some vector for the moves and monitors of this analysis
moves    = VectorMoves()
monitors = VectorMonitors()

# name the analysis
name = this_gene + "_" + "RJ"


#Set up Gamma-distributed rate variation.
alpha_morpho ~ dnExponential( 1.0 )
alpha_morpho.setValue(0.2)
rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )

#Moves on the parameters to the Gamma distribution.
moves.append(mvScale(alpha_morpho, lambda=0.01, weight=5.0))
moves.append(mvScale(alpha_morpho, lambda=0.1,  weight=3.0))
moves.append(mvScale(alpha_morpho, lambda=1,    weight=1.0))

clock_morpho ~ dnExponential(1.0)

moves.append(mvScale(clock_morpho, lambda=0.01, weight=5.0))
moves.append(mvScale(clock_morpho, lambda=0.1,  weight=2.0))
moves.append(mvScale(clock_morpho, lambda=1,    weight=1.0))

# Set up branch length moves
br_len_lambda ~ dnExp(0.2)
moves.append( mvScale(br_len_lambda, weight=5))

nbr <- 2*taxa.size() - 3
for (i in 1:nbr){
    br_lens[i] ~ dnExponential(br_len_lambda)
    moves.append(mvScale(br_lens[i]))
}

#`Create a starting tree and place moves.append on it.
tau ~ dnUniformTopology(taxa)
phylogeny := treeAssembly(tau, br_lens)
moves.append(mvNNI(tau, weight=2*nbr))
moves.append( mvSPR(tau, weight=nbr))
tree_length := phylogeny.treeLength()
###########################################
# Mk Model
n_max_states <- 7
idx = 1
morpho_bystate[1] <- data
for (i in 2:n_max_states) {
    morpho_bystate[i] <- data                                # make local tmp copy of data
    morpho_bystate[i].setNumStatesPartition(i)                 # only keep character blocks with state space equal to size i
    nc = morpho_bystate[i].nchar()                             # get number of characters per character size with i-sized states

    if (nc > 0) {                                              # for non-empty character blocks
        Q_Mk[idx] <- fnJC(i)                                      # make i-by-i rate matrix
        idx = idx + 1                                          # increment counter
        idx
    }
}
###########################################
##########################################
#SHDM Model
# Draw the concentration parameter of the Dirichlet distribution of equilibrium state frequencies from an exponential hyperprior, and place a move on it.
dir_alpha ~ dnExponential( 1.0 )
moves.append( mvSlice(dir_alpha, weight=5.0 ) )

# Set up gamma-distributed rate variation.
#alpha_morpho ~ dnUniform( 0.0, 1E6 )
#rates_morpho := fnDiscretizeGamma( alpha_morpho, alpha_morpho, 4 )

# Move on the shape parameter of the gamma distribution.
#moves.append( mvSlice(alpha_morpho, weight=2.0) )

# How many distinct rate matrices we want in the mixture. Note that since we have to
# create a symmetric counterpart for each matrix, the total number is going to equal
# twice the value specified below.
n_cats = 3

n_max_states <- 7
idx = 1

for (i in 2:n_max_states) {
    morpho_bystate[i - 1] <- data                             # make local tmp copy of data
    morpho_bystate[i - 1].setNumStatesPartition(i)              # only keep character blocks with state space equal to size i
    nc = morpho_bystate[i - 1].nchar()                          # get number of characters per character size with i-sized states
    if (nc > 0) {
        print("There are "+nc+" characters with "+i+" states.")
        # Place a symmetric Dirichlet prior on the equilibrium state frequencies
        pi_prior[idx] := rep(dir_alpha, i)

        for (j in 1:n_cats) {
            # Draw a vector of equilibrium state frequencies from the specified prior
            pi[idx][j] ~ dnDirichlet(pi_prior[idx])
            moves.append( mvSimplexElementScale(pi[idx][j], alpha=10, weight=1.0) )

            # Reverse the pi[idx][j] vector

            upper = pi[idx][j].size()
            for (k in 1:upper) {
                ind = upper + 1 - k
                rev_pi[idx][j][k] <- pi[idx][j][ind]
            }

            # Create i-by-i rate matrices from both the original and reversed state
            # frequency vectors.

            Q_SHDM[idx][2*j - 1] := fnF81(pi[idx][j])
            # Need to apply simplex() to convert rev_pi[idx][j] from type Probability[]
            Q_SHDM[idx][2*j] := fnF81(simplex(rev_pi[idx][j]))
        }

        print("The mixture contains "+Q_SHDM[idx].size()+" rate matrices:")
        for (l in 1:Q_SHDM[idx].size()) {
            print(" ")
            Q_SHDM[idx][l]
        }

        # Tell the model what the probability of a character going into any particular
        # category of the rate matrix mixture. The flat Dirichlet prior used here says
        # that a character is equally likely to be put into any category.

        mat_prior[idx] <- rep(1, 2*n_cats)
        matrix_probs[idx] ~ dnDirichlet(mat_prior[idx])

        # Place move on the category assignment probabilities
        moves.append( mvBetaSimplex(matrix_probs[idx], weight=3.0) )
        moves.append( mvDirichletSimplex(matrix_probs[idx], weight=1.5) )

        # Combine all of our elements into a CTMC. Because we have not observed any
        # invariant sites, we specify the coding as 'variable'. Note that we are now
        # feeding the site matrices to the CTMC.

        idx = idx + 1                                            # increment counter
    }
}
##########################################

Q_vec = v(Q_Mk, Q_SHDM)

model_indicator ~ dnCategorical(simplex(1,1))
moves.append( mvRandomGeometricWalk(model_indicator, weight=10.0, tune=FALSE) )

Q := Q_vec[model_indicator]


# Alternative approch
#Q ~ dnMixture( values=Q_vec, probabilities=simplex(rep(1,Q_vec.size())) )
#model_indicator := Q.getAllocationIndex()
#
#moves.append( mvGibbsMixtureAllocation(Q, weight=2.0)

#################################################
# Define the model of among-site rate variation #
#################################################

alpha ~ dnReversibleJumpMixture(1E8, dnUniform(0,1E8), 0.5)
moves.append( mvRJSwitch(alpha, weight=10.0) )
moves.append( mvScale(alpha, weight=10.0) )

alpha_indicator := ifelse(alpha == 1E8, 0, 1)

site_rates := fnDiscretizeGamma(alpha, alpha, 4)

#################################
# Define the phyloCTMC model    #
# (AKA the likelihood function) #
#################################

seq ~ dnPhyloCTMC(tree=phylogeny, Q=Q, type="standard", siteRates=site_rates)
seq.clamp(data) # attach the observed data

#########################
# Make the model object #
#########################

my_model = model(phylogeny)

#####################
# Make the monitors #
#####################

monitors.append( mnModel(filename="output/" + name + "/posterior_samples.log",printgen=10, separator = TAB) )
monitors.append( mnFile(filename="output/" + name + "/tree_samples.trees",printgen=10, separator = TAB, phylogeny) )
monitors.append( mnScreen(printgen=1000, model_indicator, alpha_indicator) )

################
# Run the MCMC #
################

mymcmc = mcmc(my_model, moves, monitors, nruns=2, combine="mixed")
mymcmc.run(generations=20000,tuningInterval=200)

#########################################
# Read in the posterior sample of trees #
# and compute the MAP tree              #
#########################################

# start by reading in the tree trace
treetrace = readTreeTrace("output/" + name + "/tree_samples.trees")
map_tree = mapTree(treetrace,"output/" + name + "/MAP_tree.tree")

# exit the program
q()
